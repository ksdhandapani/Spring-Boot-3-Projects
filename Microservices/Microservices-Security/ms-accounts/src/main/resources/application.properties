spring.application.name=ms-accounts

# Default profile that I want to use
spring.profiles.active=prod
# Location of the Config Server - Running on local
spring.config.import=optional:configserver:http://localhost:8071/

server.port=8080

# Datasource properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# OpenAPI Swagger properties
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true

# Telling Spring Boot Actuator to enable and expose all management endpoints
management.endpoints.web.exposure.include=*
# Enabling Health Check details for Readiness and Liveness Probes
management.health.readinessstate.enabled=true
management.health.livenessstate.enabled=true
# Enabling Probes Endpoint
management.endpoint.health.probes.enabled=true
# Enable info property
management.info.env.enabled=true
# We are telling Spring Boot Actuator to add a custom tag named application with the value as the spring.application.name property value (ms-accounts) for all the metrics collected by Micrometer
management.metrics.tags.application=${spring.application.name}

# Whenever the Accounts/Loans/Cards Microservice is trying to register with Eureka Server by default it will try to register with the Hostname (Hostname is useful whenever we are trying to use the DNS mapping inside our microservices network, but inside our local system we do not have any DNS mapping set up, so we should use preferIpAddress as true so that our Accounts/Loans/Cards microservice will register with Eureka Server by using the IP address. Behind the scenes, whenever the other microservices are trying to connect with the service, Eureka Server will share the IP address details of the service.)
eureka.instance.preferIpAddress=true
# The Accounts/Loans/Cards microservice will try to fetch the registry details whenever it is trying to connect with other microservices
eureka.client.fetchRegistry=true
# We want our Accounts/Loans/Cards microservice to be registered with Eureka Server
eureka.client.registerWithEureka=true
# Eureka Service URL - Running on local
eureka.client.serviceUrl.defaultZone=http://localhost:8070/eureka

# The below information will be shown in Eureka Server's Dashboard
info.app.name=ms-accounts
info.app.description= XYZ Bank Accounts Application
info.app.version=1.0.0



# enabled.true is deprecated, use access.unrestricted instead
management.endpoint.shutdown.access=unrestricted

# Setting this property is no longer required and can be ignored
#endpoints.shutdown.enabled=true

logging.level.com.dhandapani.ms_accounts=DEBUG
# For Distributed Tracing using Open Telemetry, we are customizing the log pattern to include trace id and span id in each log statement
logging.pattern.level=%5p [${spring.application.name},%X{trace_id},%X{span_id}]

### CIRCUIT BREAKER CONFIGURATION - RESILIENCE4J

spring.cloud.openfeign.circuitbreaker.enabled=true

# We are communicating the circuit breaker pattern on how many requests it has to initially monitor before it tries to change the status from CLOSE to OPEN. In other words, with this property, we are instructing our circuit breaker pattern to monitor at least 10 requests coming towards the services. After monitoring 10 requests, you can make a decision whether to continue with the CLOSE status or to move to the OPEN status. 
resilience4j.circuitbreaker.configs.default.slidingWindowSize=10

# Once our Circuit Breaker Pattern moves to the OPEN state, it will never be in the OPEN state forever. Periodically, it is going to move to the HALF_OPEN state, and it is going to allow a certain amount of traffic to the services, and since the pattern cannot decide how many requests it has to pass, we need to provide that information using this property.
# So here we are giving 2, which means we want our pattern to allow two requests in the HALF_OPEN state. Based upon these two requests being processed, it can decide whether to go back to the OPEN state or move to the CLOSED state.
resilience4j.circuitbreaker.configs.default.permittedNumberOfCallsInHalfOpenState=2

# If at least 50% of my requests fail, then our pattern can move to the OPEN state from the CLOSED state.
resilience4j.circuitbreaker.configs.default.failureRateThreshold=50

# Our pattern is going to wait for 10s (10000 ms) whenever it tries to move to the HALF_OPEN state and allow the partial traffic.
resilience4j.circuitbreaker.configs.default.waitDurationInOpenState=10000

### RETRY CONFIGURATION - RESILIENCE4J

# We are communicating the retry pattern on how many attempts it has to make before it gives up
resilience4j.retry.configs.default.max-attempts=3
# We are communicating the retry pattern to wait for 100ms between each retry attempt
resilience4j.retry.configs.default.wait-duration=100
# Enabling Exponential Backoff for Retry Pattern
resilience4j.retry.configs.default.enable-exponential-backoff=true
# Multiplier used for Exponential Backoff to increase the wait time after each retry
# Factor by which the wait duration increases after each retry attempt (e.g., 100ms, 200ms, 400ms)
resilience4j.retry.configs.default.exponential-backoff-multiplier=2
# We are communicating the retry pattern to ignore the below exception and not to retry if this exception occurs
# When we define value for "resilience4j.retry.configs.default.retry-exceptions", we do not need to define value for "resilience4j.retry.configs.default.ignore-exceptions", we can completely ignore this key
#resilience4j.retry.configs.default.ignore-exceptions=java.lang.NullPointerException
# We are communicating the retry pattern to retry if any of the below exceptions occur
resilience4j.retry.configs.default.retry-exceptions=java.util.concurrent.TimeoutException

### RATE LIMITER CONFIGURATION - RESILIENCE4J

# We are communicating the rate limiter pattern on how long the client should wait to acquire permission when the limit is exceeded, i.e., if the client exceeds the defined limit, it will wait for 1000ms (1 second) to acquire permission before throwing an exception
resilience4j.ratelimiter.configs.default.timeoutDuration=1000
# We are communicating the rate limiter pattern the time period after which the limit will be refreshed, i.e., after every 5 seconds, the limit will be refreshed
resilience4j.ratelimiter.configs.default.limitRefreshPeriod=5000
# We are communicating the rate limiter pattern to allow only 1 request per defined limitRefreshPeriod
resilience4j.ratelimiter.configs.default.limitForPeriod=1
