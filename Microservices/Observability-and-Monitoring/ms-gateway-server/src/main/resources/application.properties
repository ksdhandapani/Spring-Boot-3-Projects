spring.application.name=ms-gateway-server

# Location of the Config Server - Running on local
spring.config.import=optional:configserver:http://localhost:8071/

# We are telling our Gateway Server to connect with the Discovery Server (ms-eurekaserver) and locate all details about the microservices
# Once the Gateway server locates details about individual microservices, it will start forwarding the requests from external clients to individual microservices
# Make it false if you want to have only your custom routing configuration
spring.cloud.gateway.discovery.locator.enabled=false
# We are telling Gateway Server to accept service names in lower case
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true

### HTTP CLIENT TIMEOUT CONFIGURATION
spring.cloud.gateway.httpclient.connect-timeout=1000
spring.cloud.gateway.httpclient.response-timeout=10s


# Telling Spring Boot Actuator to enable and expose all management endpoints
management.endpoints.web.exposure.include=*
# To enable gateway related endpoints inside Actuator
management.endpoint.gateway.access=unrestricted
# Enable info property
management.info.env.enabled=true
# We are telling Spring Boot Actuator to add a custom tag named application with the value as the spring.application.name property value (ms-gateway-server) for all the metrics collected by Micrometer
management.metrics.tags.application=${spring.application.name}

# The below information will be shown in Eureka Server's Dashboard
info.app.name=ms-gateway-server
info.app.description=Edge Server for XYZ Bank
info.app.version=1.0.0

logging.level.com.dhandapani.ms_gateway_server=DEBUG
# For Distributed Tracing using Open Telemetry, we are customizing the log pattern to include trace id and span id in each log statement
logging.pattern.level=%5p [${spring.application.name},%X{trace_id},%X{span_id}]

### CIRCUIT BREAKER CONFIGURATION - RESILIENCE4J

# We are communicating the circuit breaker pattern on how many requests it has to initially monitor before it tries to change the status from CLOSE to OPEN. In other words, with this property, we are instructing our circuit breaker pattern to monitor at least 10 requests coming towards the services. After monitoring 10 requests, you can make a decision whether to continue with the CLOSE status or to move to the OPEN status. 
resilience4j.circuitbreaker.configs.default.slidingWindowSize=10

# Once our Circuit Breaker Pattern moves to the OPEN state, it will never be in the OPEN state forever. Periodically, it is going to move to the HALF_OPEN state, and it is going to allow a certain amount of traffic to the services, and since the pattern cannot decide how many requests it has to pass, we need to provide that information using this property.
# So here we are giving 2, which means we want our pattern to allow two requests in the HALF_OPEN state. Based upon these two requests being processed, it can decide whether to go back to the OPEN state or move to the CLOSED state.
resilience4j.circuitbreaker.configs.default.permittedNumberOfCallsInHalfOpenState=2

# If at least 50% of my requests fail, then our pattern can move to the OPEN state from the CLOSED state.
resilience4j.circuitbreaker.configs.default.failureRateThreshold=50

# Our pattern is going to wait for 10s (10000 ms) whenever it tries to move to the HALF_OPEN state and allow the partial traffic.
resilience4j.circuitbreaker.configs.default.waitDurationInOpenState=10000

resilience4j.timelimiter.configs.default.timeout-duration=7000

### REDIS CONFIGURATION FOR RATE LIMITING
spring.data.redis.connect-timeout=2s
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.timeout=1s
